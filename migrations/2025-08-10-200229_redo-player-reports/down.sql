drop index data.close_not_included_report_attribute_versions;
drop index data.close_not_included_report_versions;

drop trigger on_insert_player_version_trigger on data.player_versions;
drop function data.on_insert_player_version;
create function data.on_insert_player_version()
    returns trigger as $$
begin
    -- check if the currently-valid version is exactly identical to the new version
    -- the list of columns must exactly match the ones in data.player_versions or
    -- we'll miss changes
    perform 1
    from data.player_versions pv
    where pv.mmolb_player_id = NEW.mmolb_player_id
      and pv.valid_until is null
      -- note: "is not distinct from" is like "=" except for how it treats nulls.
      -- in postgres, NULL = NULL is false but NULL is not distinct from NULL is true
      and pv.first_name is not distinct from NEW.first_name
      and pv.last_name is not distinct from NEW.last_name
      and pv.batting_handedness is not distinct from NEW.batting_handedness
      and pv.pitching_handedness is not distinct from NEW.pitching_handedness
      and pv.home is not distinct from NEW.home
      and pv.birthseason is not distinct from NEW.birthseason
      and pv.birthday_type is not distinct from NEW.birthday_type
      and pv.birthday_day is not distinct from NEW.birthday_day
      and pv.birthday_superstar_day is not distinct from NEW.birthday_superstar_day
      and pv.likes is not distinct from NEW.likes
      and pv.dislikes is not distinct from NEW.dislikes
      and pv.number is not distinct from NEW.number
      and pv.mmolb_team_id is not distinct from NEW.mmolb_team_id
      and pv.slot is not distinct from NEW.slot
      and pv.durability is not distinct from NEW.durability
      and pv.greater_boon is not distinct from NEW.greater_boon
      and pv.lesser_boon is not distinct from NEW.lesser_boon
      and pv.num_modifications is not distinct from NEW.num_modifications
      and pv.occupied_equipment_slots is not distinct from NEW.occupied_equipment_slots;

    -- if there was an exact match, suppress this insert
    if FOUND then
        update data.player_versions
        set duplicates = duplicates + 1
        where mmolb_player_id = NEW.mmolb_player_id and valid_until is null;

        return null;
    end if;

    -- otherwise, close out the currently-valid version...
    update data.player_versions
    set valid_until = NEW.valid_from
    where mmolb_player_id = NEW.mmolb_player_id and valid_until is null;

    -- ...and any modifications that are now past the end of the modifications list...
    update data.player_modification_versions
    set valid_until = NEW.valid_from
    where mmolb_player_id = NEW.mmolb_player_id
      and modification_index >= NEW.num_modifications
      and valid_until is null;

    -- ...and any equipment in a slot that's no longer occupied...
    update data.player_equipment_versions
    set valid_until = NEW.valid_from
    where mmolb_player_id = NEW.mmolb_player_id
      and not equipment_slot = ANY(NEW.occupied_equipment_slots)
      and valid_until is null;

    -- ...and any equipment effects for equipment in a slot that's no longer occupied...
    update data.player_equipment_effect_versions
    set valid_until = NEW.valid_until
    where mmolb_player_id = NEW.mmolb_player_id
      and not equipment_slot = ANY(NEW.occupied_equipment_slots)
      and valid_until is null;

    -- ...and return the new row so it gets inserted as normal
    return NEW;
end;
$$ language plpgsql;

create trigger on_insert_player_version_trigger
    before insert on data.player_versions
    for each row
execute function data.on_insert_player_version();

alter table data.player_versions
    drop column included_report_categories;

drop trigger on_insert_player_report_attribute_version_trigger on data.player_report_attribute_versions;
drop function data.on_insert_player_report_attribute_version;
drop table data.player_report_attribute_versions;

drop trigger on_insert_player_report_version_trigger on data.player_report_versions;
drop function data.on_insert_player_report_version;
drop table data.player_report_versions;

-- autogenerated by rustrover, hopefully is correct
create table data.player_report_attributes
(
    id              bigserial not null
        constraint player_reports_pkey
            primary key,
    mmolb_player_id text                                                           not null,
    season          integer                                                        not null,
    day_type        bigint
        constraint player_reports_day_type_fkey
            references taxa.day_type,
    day             integer,
    superstar_day   integer,
    observed        timestamp                                                      not null,
    attribute       bigint                                                         not null
        constraint player_reports_attribute_fkey
            references taxa.attribute,
    stars           integer                                                        not null,
    constraint player_reports_mmolb_player_id_season_day_type_day_supersta_key
        unique (mmolb_player_id, season, day_type, day, superstar_day, attribute)
);

create function data.on_insert_player_report_attribute()
    returns trigger as $$
begin
    perform 1
    from data.player_report_attributes pr
    where pr.mmolb_player_id = NEW.mmolb_player_id
      -- note: "is not distinct from" is like "=" except for how it treats nulls.
      -- in postgres, NULL = NULL is false but NULL is not distinct from NULL is true
      and pr.season is not distinct from NEW.season
      and pr.day_type is not distinct from NEW.day_type
      and pr.day is not distinct from NEW.day
      and pr.superstar_day is not distinct from NEW.superstar_day
      -- NOTE: `observed` should NOT be in the conditions. Each attempted insert
      -- will have a new `observed`, but we only want to keep the first one.

      -- attribute and stars are not necessary for correctness. i'm keeping them for
      -- now to help me catch bugs
      and pr.attribute is not distinct from NEW.attribute
      and pr.stars is not distinct from NEW.stars;

    -- if there was an exact match, suppress this insert
    if FOUND then
        return null;
    end if;

    -- otherwise, return the new row so it gets inserted as normal
    return NEW;
end;
$$ language plpgsql;

create trigger on_insert_player_report_attribute_trigger
    before insert on data.player_report_attributes
    for each row
execute function data.on_insert_player_report_attribute();
